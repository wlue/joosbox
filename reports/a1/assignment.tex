\documentclass[letterpaper]{article}
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{soul}
\usepackage{fancyhdr, lastpage}
\usepackage{graphicx}
\pagestyle{fancy}
\fancyhf{}
\usepackage{minted}
\usemintedstyle{pastie}

\newcommand{\spacer}{\vspace{5mm}\hrule\vspace{5mm}}

\makeatletter
\renewcommand{\@maketitle}{
  \begin{center}%
    {\LARGE \@title \par}%
  \end{center}%
  \vspace*{40pt}
  \noindent \Large \@date \par %
  \vspace*{20pt}
  \noindent \Large \@author \par %
  \vfill
  \par
}
\makeatother

% New commands
\newcommand{\assignmentnumber}{1}
\newcommand{\course}{CS 444: Compiler Construction}
\newcommand{\term}{Winter 2013}
\newcommand{\project}{Lab \assignmentnumber: Scanning, Parsing, Weeding, AST Building}
\newcommand{\name}{wlue, cktaylor, psobot}
\newcommand{\wenhao}{wlue(??????) - Lue, Wen-Hao (wlue@uwaterloo.ca)}
\newcommand{\chris}{cktaylor(20338058) - Taylor, Chris (cktaylor@uwaterloo.ca)}
\newcommand{\peter}{psobot(20334978) - Sobot, Peter (psobot@uwaterloo.ca)}

% Values for template
\title{\course \\ \term \\ \project}
\date{\ul{\textbf{Date of Submission}}: \today}
\author{\ul{\textbf{Submitted by}}: \\ \indent \wenhao \\ \indent \chris \\ \indent \peter}

\rhead{\name{}}
\lhead{\course{} Lab \assignmentnumber}
\cfoot{Page \thepage{} of \protect\pageref{LastPage}}

% Content
\begin{document}

  \maketitle
  \thispagestyle{empty}
  \clearpage

  \tableofcontents
  \thispagestyle{empty}
  \clearpage

  \setcounter{page}{1}

  \clearpage
  \section{Introduction}

  Our CS444 compiler, named {\em Joosbox}, currently scans, parses and
  validates files, outputing a return code of {tt 0} if the file is a valid
  Joos 1W source file, and outputing a return code of 42 otherwise. Upon
  parsing an invalid Joos 1W program, Joosbox will output diagnostic
  information (including line number and character index of invalid tokens) to
  standard error. Joosbox is implemented in Scala.

  \section{Design}

  Joosbox is split into three primary components: the lexer, the parser, and
  the abstract syntax tree builder.

  \subsection{Lexer}

  Joosbox's lexer is based on a grammar Joos1W, a subset of th Java 1.3. Using
  the feature chart of Joos1W we were able to construct a series regexes that
  would match a given valid token type. From each regex, we then constructed a
  corresponding NFA by hand. To accomodate this, we designed our own NFA data
  structure.

  \subsection{Parser}

  Joosbox uses an LALR(1) grammar to parse Joos 1W. This grammar is based on a
  LALR(1) grammar for Java 1 itself, with numerous tokens removed and altered to
  match the language features we were supporting as specified by Joos 1W. The
  LALR(1) grammar for Java 1 that we derived our grammer from was found in
  Chapter 19 of {\em The Java Language Specification}. From this collection of
  production rules for a Java 1 LALR(1) grammar, we were able to construct our
  grammar in the form of {\tt joos1w.cfg}.

  The provided {\tt jlalr1.java} program for constructing a parse table from a
  {\tt .cfg} file. With this program we were able to contstruct a LALR(1) parse
  table for our grammar in the form of {\tt joos1w.lr1}. This file was used at
  runtime by Joosbox to parse the Joos1W language.

  To parse the sequence of tokens output by the lexer, Joosbox first discards
  tokens that do not have corresponding semantic value in the grammar (i.e.:
  whitespace, comments, etc) in a ``pre-parse weeding'' step. At this step,
  any tokens that are lexically valid but not semantically valid in Joos
  (including Java constructs that are reserved keywords, but not supported,
  like {\tt throw}) will cause a {\tt SyntaxError} to be raised.

  Once the input tokens are pre-weeded, the LALR(1) algorithm with tree building
  (from CS 241) is used to construct a basic parse tree. The resulting parse 
  tree output is built out of {\tt ParseTreeNode}s, arbitrary expressions
  that can contain zero or more child nodes and an optional value.

  \subsection{Abstract Syntax Tree}

  Joosbox accomplishes weeding, or post-parsing validation of semantic input,
  as a validation step during the construction of the Abstract Syntax Tree.

  \section{Challenges}

  %TODO: Talk about bundling together the Scala code into one single jar
  %TODO: Talk about code generation from Python to Scala

  \section{Testing}

  %TODO: Talk about marmoset tests being imported into our SBT local test suite
  %TODO: Talk about the TDD approach
  %TODO: Talk about how every intermediate data representation was heavily tested

\end{document}
