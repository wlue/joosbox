\documentclass[letterpaper]{article}
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{soul}
\usepackage{fancyhdr, lastpage}
\usepackage{graphicx}
\pagestyle{fancy}
\fancyhf{}
\usepackage{minted}
\usemintedstyle{pastie}

\newcommand{\spacer}{\vspace{5mm}\hrule\vspace{5mm}}

\makeatletter
\renewcommand{\@maketitle}{
  \begin{center}%
    {\LARGE \@title \par}%
  \end{center}%
  \vspace*{40pt}
  \noindent \Large \@date \par %
  \vspace*{20pt}
  \noindent \Large \@author \par %
  \vfill
  \par
}
\makeatother

% New commands
\newcommand{\assignmentnumber}{5}
\newcommand{\course}{CS 444: Compiler Construction}
\newcommand{\term}{Winter 2014}
\newcommand{\project}{Labs \assignmentnumber: Code Generation}
\newcommand{\name}{wlue, cktaylor, psobot}
\newcommand{\wenhao}{wlue(20349659) - Lue, Wen-Hao (wlue@uwaterloo.ca)}
\newcommand{\chris}{cktaylor(20338058) - Taylor, Chris (cktaylor@uwaterloo.ca)}
\newcommand{\peter}{psobot(20334978) - Sobot, Peter (psobot@uwaterloo.ca)}

% Values for template
\title{\course \\ \term \\ \project}
\date{\ul{\textbf{Date of Submission}}: \today}
\author{\ul{\textbf{Submitted by}}: \\ \indent \wenhao \\ \indent \chris \\ \indent \peter}

\rhead{\name{}}
\lhead{\course{} Assignment \assignmentnumber}
\cfoot{Page \thepage{} of \protect\pageref{LastPage}}

% Content
\begin{document}

  \maketitle
  \thispagestyle{empty}
  \clearpage

  \setcounter{page}{1}

  \clearpage
  \section{Introduction}

  Our Joos1W compiler, named {\em Joosbox}, currently performs the following
  operations on all programs passed in on the command line:

  \begin{itemize}
    \item Scanning
    \item Parsing
    \item Weeding
    \item Environment Building
    \item Type Linking
    \item Hierarchy Checking
    \item Name Resolution
    \item Type Checking
    \item Static Analysis
    \item Code Generation
  \end{itemize}

  When passed a valid Joos1W program, Joosbox will print nothing on standard
  error or standard output, and will return a {\tt 0} return code. A single
  i386 assembly language file, located at the path {\tt
  output/concatenated.s}, will contain the assembly-language representation of
  the provided Joos program.

  Upon parsing an invalid Joos1W program, Joosbox will output diagnostic
  information (including line number and character index of invalid tokens, if
  available) to the standard error stream. Joosbox will then return {\tt 42}.

  Joosbox is implemented in Scala, and makes use of only four libraries ---
  the Scala standard library, the {\tt SBT} build tool, the {\tt Specs2}
  testing framework, and Apache Commons Lang. This document outlines the
  design of Joosbox, enumerates the significant challenges encountered during
  its construction, and describes our group's testing process for the final
  phase of the project: code generation.

  \section{Design}
  \subsection{VTables}

  \subsubsection{Hierarchy}

  \subsubsection{Dynamic Dispatch}

  \subsection{Arrays}

  The way in which Joosbox generates code for arrays is to special case it and
  to create an Array layout that provides a simplistic solution to storage of
  array contents and length field lookup while still accomodating everything
  else with Array being a reference type and object.

  % TODO - Mockup of Array layout

  The contained type tag is either a class tag of another valid reference type
  or a constant hardcoded type tag for the 5 supported primitives: {\tt
  BooleanTypeTag}, {\tt ByteTypeTag}, {\tt ShortTypeTag}. {\tt IntTypeTag},
  {\tt CharTypeTag}.

  \subsubsection{Array Covariance}

  \subsection{Strings}

  Many properties of Joos strings made them an interesting case to handle in
  code generation. Firstly, the property that Strings are reference types (to
  java.lang.String) while being data backed by arrays, another special reference
  type, made it a case that needed special handling. Additionally, String
  objects have very specific addition properties in that any String object can
  be concatenated with some other non-String types. The former, means that
  Joosbox needs to consider efficiency and must implement string interning. The
  latter, means that Joosbox needs to generate specific code just for String
  concatenation.

  \subsubsection{String Literal Interning}

  String interning is accomplished in Joosbox, by using a pool of String objects
  as mapped by their string literals. One of the initial code generation steps
  is to recursively traverse the AST and map string literal nodes to string
  literals in the pool (adding them to the pool when no matching literal can be
  found in the pool already). We then generate the assembly for the string pool
  in a data secion, that inlines the character array layout of the string and a
  java.lang.String object layout whose {\tt chars} field has a reference to the
  character array layout.

  With this Joosbox supported reference equality for equivalent string objects
  from the onset, as equal string nodes will both refer to the same object in
  the string pool.

  \subsubsection{String Concatenation}

  The assembly generated for string concatenation utilized the underlying
  methods of the java.lang.String class such as to take advantage of that
  pre-existing code. The way in which Joosbox accomplishes this is to take each
  operand in a concatenation expression, and promote it to a String object by
  using the java.lang.String static {\tt valueOf} methods. This was accomplished
  by determining the type of the operand, and then performing a method lookup on
  java.lang.String to find the corresponding {\tt valueOf} method that takes
  that type of argument. Once we have String objects, Joosbox will actually
  concatenate them by making use of java.lang.String instance {\tt concat}
  method.

  Taking advantage of these existing methods, allowed it so that the {\tt
  CodeGenerator} only needed to invoke the assembly generation for static and
  instance method calls.

  \section{Challenges}

  % Field initialization zeroing

  \section{Testing}
\end{document}
