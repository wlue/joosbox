\documentclass[letterpaper]{article}
\usepackage{inconsolata}
\usepackage[T1]{fontenc}
\usepackage[margin=1in]{geometry}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}
\usepackage{soul}
\usepackage{fancyhdr, lastpage}
\usepackage{graphicx}
\pagestyle{fancy}
\fancyhf{}
\usepackage{minted}
\usemintedstyle{pastie}

\newcommand{\spacer}{\vspace{5mm}\hrule\vspace{5mm}}

\makeatletter
\renewcommand{\@maketitle}{
  \begin{center}%
    {\LARGE \@title \par}%
  \end{center}%
  \vspace*{40pt}
  \noindent \Large \@date \par %
  \vspace*{20pt}
  \noindent \Large \@author \par %
  \vfill
  \par
}
\makeatother

% New commands
\newcommand{\assignmentnumber}{5}
\newcommand{\course}{CS 444: Compiler Construction}
\newcommand{\term}{Winter 2014}
\newcommand{\project}{Labs \assignmentnumber: Code Generation}
\newcommand{\name}{wlue, cktaylor, psobot}
\newcommand{\wenhao}{wlue(20349659) - Lue, Wen-Hao (wlue@uwaterloo.ca)}
\newcommand{\chris}{cktaylor(20338058) - Taylor, Chris (cktaylor@uwaterloo.ca)}
\newcommand{\peter}{psobot(20334978) - Sobot, Peter (psobot@uwaterloo.ca)}

% Values for template
\title{\course \\ \term \\ \project}
\date{\ul{\textbf{Date of Submission}}: \today}
\author{\ul{\textbf{Submitted by}}: \\ \indent \wenhao \\ \indent \chris \\ \indent \peter}

\rhead{\name{}}
\lhead{\course{} Assignment \assignmentnumber}
\cfoot{Page \thepage{} of \protect\pageref{LastPage}}

% Content
\begin{document}

  \maketitle
  \thispagestyle{empty}
  \clearpage

  \setcounter{page}{1}

  \clearpage
  \section{Introduction}

  Our Joos1W compiler, named {\em Joosbox}, currently performs the following
  operations on all programs passed in on the command line:

  \begin{itemize}
    \item Scanning
    \item Parsing
    \item Weeding
    \item Environment Building
    \item Type Linking
    \item Hierarchy Checking
    \item Name Resolution
    \item Type Checking
    \item Static Analysis
    \item Code Generation
  \end{itemize}

  When passed a valid Joos1W program, Joosbox will print nothing on standard
  error or standard output, and will return a {\tt 0} return code. A single
  i386 assembly language file, located at the path {\tt
  output/concatenated.s}, will contain the assembly-language representation of
  the provided Joos program.

  Upon parsing an invalid Joos1W program, Joosbox will output diagnostic
  information (including line number and character index of invalid tokens, if
  available) to the standard error stream. Joosbox will then return {\tt 42}.

  Joosbox is implemented in Scala, and makes use of only four libraries ---
  the Scala standard library, the {\tt SBT} build tool, the {\tt Specs2}
  testing framework, and Apache Commons Lang. This document outlines the
  design of Joosbox, enumerates the significant challenges encountered during
  its construction, and describes our group's testing process for the final
  phase of the project: code generation.

  \section{Design}

  \subsection{Basic nodes}

  A large number of our AST nodes had relatively simple code generation steps.
  These are really any of the nodes that were either single simple nodes or
  could rely on generating code for their children and using the results of the
  children assembly in a simple, correct manner. These simple code generation
  nodes included:

  \begin{itemize}
    \item Num
    \item NullLiteral
    \item FalseLiteral
    \item TrueLiteral
    \item ArithmeticExpressions (ignoring string concatention)
    \item RelationalExpression (ignoring instanceof check)
    \item NegatedExpression
    \item LogicalNotExpression
    \item ConditionalExpression
    \item IfStatement
    \item WhileStatement
    \item ForStatement
    \item ReturnStatement
    \item Block
    \item LocalVariableDeclaration
    \item ForVariableDeclaration
  \end{itemize}

  Other nodes such as class and array creation, expression name lookup,
  field access, assignment, method invocation, etc. all require substantially
  more logic and more complex assembly and as such will be exlained below.

  \subsection{Object Layout}

  \begin{center}
  \begin{tabular}{| r | l |}
    \hline
    Type Tag & {\tt 0xbeadfood } \\ \hline
    VTable Pointer & {\tt vtable\_MyClass } \\ \hline
    Instance Field & {\tt ??? } \\ 
    Instance Field & {\tt ??? } \\ 
    ... & {\tt ??? } \\ 
    Instance Field & {\tt ??? } \\ \hline
  \end{tabular}
\end{center}

% TODO: Talk about this object layout

  \subsection{VTables}

  Joosbox implements dynamic method dispatch by means of {\em virtual method
  tables}, or ``VTables,'' as they are called in the Joosbox code. Each
  concrete class contains its own VTable, which resides in the {\tt .data}
  section of the code. Each VTable is laid out like the following example,
  which shows the VTable for concrete class {\tt MyClass} that inherits from
  {\tt MySuperClass} and implements {\tt MyInterface}:

  \begin{center}
  \begin{tabular}{| l | l |}
    \hline
    vtable\_MyClass: & \\ \hline
    vtable\_MyClass\_Constructor0: & {\tt dd MyClass\_Constructor0\_Impl} \\ 
    vtable\_MyClass\_Method1: & {\tt dd MyClass\_Method1\_Impl} \\ 
    vtable\_MyClass\_Method2: & {\tt dd MyClass\_Method2\_Impl} \\ 
    vtable\_MyClass\_OverriddenMethod3: & {\tt dd MyClass\_OverriddenMethod3\_Impl} \\ 
    vtable\_MyClass\_InheritedMethod4: & {\tt dd MySuperClass\_InheritedMethod4\_Impl} \\ 
    vtable\_MyClass\_InheritedMethod5: & {\tt dd MySuperClass\_InheritedMethod5\_Impl} \\
    vtable\_MyClass\_ImplementedMethod6: & {\tt dd MyClass\_ImplementedMethod6\_Impl} \\ \hline

    vtable\_MyClass\_as\_MySuperClass: & \\ \hline
    vtable\_MyClass\_as\_MySuperClass\_Constructor0: & \tt{dd MyClass\_Constructor0\_Impl} \\
    vtable\_MyClass\_as\_MySuperClass\_OverriddenMethod3: & {\tt dd MyClass\_OverriddenMethod3\_Impl} \\ 
    vtable\_MyClass\_as\_MySuperClass\_InheritedMethod4: & {\tt dd MySuperClass\_InheritedMethod4\_Impl} \\ 
    vtable\_MyClass\_as\_MySuperClass\_InheritedMethod5: & {\tt dd MySuperClass\_InheritedMethod5\_Impl} \\ \hline

    vtable\_MyClass\_as\_MyInterface: & \\ \hline
    vtable\_MyClass\_as\_MyInterface\_ImplementedMethod6: & \tt{dd MyClass\_ImplementedMethod6\_Impl} \\ \hline
  \end{tabular}
\end{center}

  As shown in this VTable layout, each class's VTable contains a nested section that looks identical
  to the VTable for another concrete class, abstract class, or interface, but with the implementation
  pointers pointing to the concrete subclass's implementations where available. This allows Joosbox to
  dynamically determine the location of a given method given only the object itself, which contains
  a runtime type tag and a pointer to the top of this VTable.

  \subsubsection{Dynamic Dispatch}

  To accomplish this VTable-based dynamic dispatch, Joosbox makes use of a function at call
  time to determine an offset within any object's VTable, used to allow seamless casting. Although
  the function itself is written in i386 assembler, it implements the same functionality as the following
  pseudocode:

  \begin{verbatim}
// One of these methods is generated for every class, abstract class, and interface.
int getOffsetOfVTableForClassMySuperClassForObjectWithClassTag(int tag) {
  //  There will be one switch case for every concrete subclass of MySuperClass
  switch (tag) {
    //  The use of label subtraction here allows us to let the assembler do the math.
    case MyClass: return (vtable_MyClass_as_MySuperClass - vtable_MyClass);
    case MyOtherClass: return (vtable_MyOtherClass_as_MySuperClass - vtable_MyOtherClass);
    case default:
      return 0xFFFFFFFF;
  }
}
  \end{verbatim}


  During code generation, this method is generated for every concrete, abstract class, and interface,
  and contains the switch cases for all concrete classes that inherit from or implement the type.

  At each call site, the compiler generates a call to the appropriate {\tt getOffset} method,
  calling the method that corresponds to the type of the object being called upon, which is known at compile
  time. Then, once the offset within the VTable is known, the VTable pointer is incremented by this offset,
  making the new pointer behave exactly like a VTable for the target class would, with method pointers for
  the same methods living in the exact same addresses relative to the base of the VTable.

  From there on out, invoking the correct method is as simple as invoking {\tt call} and
  calculating the offset of the desired method within the VTable:

  \begin{verbatim}
; this will call whatever method that implements vtable_MySuperClass_Constructor0,
; whether it is on MySuperClass itself, or a subclass whose VTable has been ``thunked''
; and whose VTable now looks like MySuperClass's VTable.
; Again, the use of label subtraction here allows NASM to do the math for us and
; avoids mistakes when calculating offsets within data tables.

call [eax + (vtable_MySuperClass_Constructor0 - vtable_MySuperclass)]
  \end{verbatim}

  \subsubsection{Casting and Instanceof}

  To validate casts and check if one object can be an instance of another, the
  above-described {\tt getOffset} method is used. If the {\tt getOffset}
  method of a target type returns a valid offset, the cast is known to be
  valid, as the runtime type of the object has the VTable of the target type
  embedded within its own VTable. If the {\tt getOffset} method returns no
  result (indicated by {\tt 0xFFFFFFFF}) then the runtime knows the object
  cannot be cast to the desired type. For {\tt CastExpression} nodes, this
  results in a runtime error via a call to {\tt \_\_exception}, while the {\tt
  instanceof} operator instead converts the result of this method into the
  corresponding boolean value and returns that.

  \subsection{Arrays}

  Arrays are a special type of object in Joosbox, in that they have the same
  memory layout as a regular object would, but also contain additional object
  header information, as well as a variable number of instance fields.

  \begin{center}
  \begin{tabular}{| r | l | l | }
    \hline
    Type Tag & {\tt 0xbeadfood } & {\em same as Object's layout} \\ \hline
    VTable Pointer & {\tt vtable\_MyClass } & {\em same as Object's layout} \\ \hline
    Contained Type Tag & {\tt 0xabcdabcd } & {\em new for array} \\ \hline
    Length & {\tt n } & {\em new for array} \\ \hline
    Element 0 & {\tt ??? } & \\ 
    Element 1 & {\tt ??? } & \\ 
    ... & {\tt ??? } & \\ 
    Element {\tt n} & {\tt ??? } & \\ \hline
  \end{tabular}
\end{center}

  The Contained Type Tag is either the class tag of another valid reference type
  or a constant hardcoded type tag for the 5 supported primitives: {\tt
  BooleanTypeTag}, {\tt ByteTypeTag}, {\tt ShortTypeTag}, {\tt IntTypeTag}, and
  {\tt CharTypeTag}.

  \subsubsection{Array Covariance}

  To implement array covariance, Joosbox uses the same casting system used to
  determine the validity of casts, but with a slight extension. When the type
  being casted to is an array type, an additional check is performed to verify
  that both the type of the object is {\tt Array}, but also that the Contained
  Type Tag field of the object can be casted to the contained type of the
  target array type. This is implemented by using a nested call to the
  appropriate {\tt getOffset} method, then checking the result of that nested
  call and returning the appropriate offset --- which for Arrays, can only be
  {\tt 0} or {\tt NoVTableOffsetFound}. (This is due to the fact that Arrays
  cannot be inherited from, meaning that they can never have any instance
  methods defined upon them.)

  \subsection{Strings}

  Many properties of Joos strings made theminteresting to handle during the
  code generation phase. Firstly, the fact that Strings are reference types
  (of class type java.lang.String) while being data-backed by arrays (another
  special reference type) made Strings more difficult to implement, and made
  it more difficult to implement string interning. Additionally, String
  objects have very specific addition properties: any String object can be
  concatenated with most other non-String types by using the traditional plus
  operator. This meant that Joosbox needed to promote types differently to
  allow for String concatenation.

  \subsubsection{String Literal Interning}

  String interning is accomplished in Joosbox by using a pool of String
  objects generated in the {\tt .data} section of the program at compile time.
  One of the initial code generation steps involves recursively traversing the
  AST and adding all string literal nodes to the string pool, deduplicating
  instances id necessary. We then generate the assembly for the string pool in
  a data secion, that statically generates the character array object layout
  of the string, as well as a java.lang.String object whose {\tt chars} field
  is pre-initialized to point to the character array layout.

  With this implementation of string interning, Joosbox supported reference
  equality for equivalent string literals from the onset, as equal string literals
  will both refer to the same object in the string pool.

  \subsubsection{String Concatenation}

  The assembly generated for string concatenation utilized the underlying
  methods of the java.lang.String class such as to take advantage of that
  pre-existing code. The way in which Joosbox accomplishes this is to take each
  operand in a concatenation expression and promote it to a String object by
  using the java.lang.String static {\tt valueOf} methods. This was accomplished
  by determining the type of the operand, and then performing a method lookup on
  java.lang.String to find the corresponding {\tt valueOf} method that takes
  that type of argument. Once String objects are found, Joosbox will actually
  concatenate them by making use of the {\tt concat} instance
  method on java.lang.String.

  Using these existing methods allowed our {\tt CodeGenerator} to avoid
  generating specific assembly code just for string concatenation, instead
  using predefined static and instance methods that exist in the standard
  library.

  \section{Challenges}

  % Field initialization zeroing

  \section{Testing}
\end{document}
